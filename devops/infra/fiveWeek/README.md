1. 단일 호스트의 성능 끌어내기
- 성능, 부하란 무엇인가
1)서버 리소스의 이용현황을 파악하기 위한 계측방법
2)OS의 동작원리
  부하를 안다는 것은 OS의 상태를 안다는 것이므로 OS가 어떻게 동작하는지를 모르면서 상태를 진단할 수는 없다.
  멀티태크킹의 동작원리는 프로세스의 상태와 부하의 관계를 밝혀준다. 웹 애플리케이션의 부하분산은 많은 경우에 '디스크 I/O를 분산하고 경감시키는' 작업이다.
  OS는 I/O를 경감시키기 위해 캐시의 구조를 내포하고 있다. 캐시가 가장 효율적으로 동작할 수 있도록 시스템을 구성해야 한다.
  
2. 추측하지 말라, 계측하라
ps, top sar 등의 툴을 사용

3. 병목 규명작업의 기본적인 흐름
- Load Average 확인
top, uptime으로 확인
Load Average는 낮은데 전송량이 오르지 않는 경우, 소프트웨어 설정이나 오류, 네트워크, 원격 호스트 측에 원인이 없는지 살펴본다.

- CPU, I/O 중 병목 원인 조사
Load Average가 높은 경우 sar, vmstat으로 시간 경과에 따라 CPU 사용률이나 I/O 대기율 추이를 확인한다.

- CPU 부하가 높은 경우
  사용자/시스템 프로그램 중 원인을 확인 
  프로세스 상태나 CPU 사용시간 등을 통해 원인이 되는 프로세스 확인
  strace 등을 통해 병목지점을 좁혀나간다.
  
- I/O 부하가 높은 경우
  입출력이 많아 부하가 높거나, Swap이 발생해서 디스크 액세스가 발생하고 있는 경우가 대부분이다. 전자만 해당할 경우 캐시에 필요한 메모리가 부족한 경우를 생각할 수 있다. 메모리 증설 혹은 데이터분산/캐시서버 도입 등을 검토한다. 프로그램을 개선하여 I/O빈도를 줄이는 것도 검토한다.
  특정 프로세스가 극단적으로 메모리를 소비하고 있는지 확인한다.

4. 부하란 무엇인가
- 두 종류의 부하
  일반적으로 WAS는 CPU bound, DB서버는 I/O bound 서버이다.

- 멀티태스킹 OS와 부하
  실행할 태스크가 늘어나면, 처리를 실행하려고 해도 대기한다
  load average : 1m, 5m, 15m 동안에 단위시간당 대기된 태스크 수, 즉 평균적으로 어느 정도의 태스크가 대기상태로 있었는지를 보고하는 수치이다.
  그렇다면 어떤 프로세스가 부하의 원인일까?
  
- 부하의 정체 알기=커널의 동작 알기
  태스크의 대기를 제어하는 것은 리눅스 커널 내에서도 프로세스 스케줄러이다. 
  프로세스 스케줄러는 멀티태스킹의 제어에 있어서 실행할 태스크의 우선순위를 결ㅈ벙해서 태스크를 대기시키거나 재개하는 등 커널의 중추적인 일을 담당한다.

- 프로세스 스케줄링과 프로세스 상태 
  프로세스는 프로그램이 OS에 의해 실행되고 있을 때 그 실행단위가 되는 개념이다. 프로세스는 커널 내부에서의 실행단위를 나타내는 태스크와는 구별되긴하지만 넓은 의미에서는 거의 같다.
  프로세스란 '프로그램의 명령'과 '실행시에 필요한 정보' 조합의 오브젝트를 말한다. 
  리눅스 커널은 프로세스마다 프로세스 디스크립터라는 관리용 테이블을 생성한다. 이 프로세스 디스크립터에 각종 실행시 정보가 저장된다.
  리눅스 커널은 이 프로세스 디스크립터 군을 우선도가 높은 순으로 재배열해서 실행순으로 '프로세서=태스크'가 실행되도록 조정한다. 이 조정 역할을 하는 것이 프로세스 스케줄러이다.
  
- 프로세스 상태변화 정리
//

- Load Average로 환산되는 대기상태
  TASK_RUNNING: CPU를 사용하고 사용하고자 해도 다른 프로세스가 CPU를 사용하고 있어서 기다리고 있는 프로세스
  TASK_UNINTERRUPTIBLE: 계속해서 처리하고자 해도 디스크 입출력이 끝날 때까지 기다려야만 하는 프로세스
  즉, 키보드 입력대기나 sleep에 의한 대기는 프로그램이 스스로 명시적으로 기다리는 것이므로 Load Average에 포함되지 않는다. 원격호스트로부터의 데이터 착신대기도 언제 데이터가 올지 불확실하므로 포함되지 않는다.

- Load Average가 보고하는 부하의 정체

5. Load Average를 계산하는 커널 코드

6. CPU사용률과 IO대기율
- sar로 CPU사용률, I/O대기율 확인
- CPU의 사용자 모드와 시스템 모드
- I/O 바운드인 경우의 sar

7. 멀티 CPU와 CPU사용률

8. CPU 사용률이 계산되는 원리

9. 프로세스 어카운팅의 커널 코드 확인

10. 쓰레드와 프로세스
- 커널 내부에서의 프로세스와 쓰레드
- ps와 쓰레드
- LinuxThreads와 NPTL

11. ps, sar, vmstat 사용법
- ps
- VSZ와 RSS
- TIME은 CPU사용시간
- 블로킹과 busy 루프의 차이를 ps로 확인
- sar
- sar -u
- sar -q
- sar -r
- I/O 부하경감과 페이지 캐시
- 페이지 캐시에 의한 I/O 부하의 경감 효과
- 페이지 캐시는 한번의 read에서 시작된다.
- sar -W
- vmstat

12. OS 튜닝이란 부하의 원인을 알고 이를 제거하는 것

