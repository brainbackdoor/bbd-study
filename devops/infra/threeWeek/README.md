```
DB서버가 정지할 경우로는 크게,
 - mysqld가 비정상 종료함
 - 디스크가 가득참
 - 디스크가 고장남
 - 서버 전원이 고장남
 
이 중 H/W가 고장난 경우에는 RAID나 다중화 구성이더라도 단시간에 데이터를 복구하기까지 시간 소요가 크다. 
이에 실시간으로 복제하는 Replication이 필요하다.

MySQL Replication의 master/slave는 1:n관계이다. 
master는 갱신과 참조 쿼리를 받아들여 바이너리 로그파일로 기록한다. 
이 로그파일의 내용이 slave로 전송되고 순차적으로 실행함으로써 복제된다. 
즉, 데이터조작쿼리(INSERT, UPDATE, DELETE)는 마스터로, 데이터조회쿼리(SELECT)는 슬레이브로 받아서 부하분산 (scale out까지)할 수 있다. 
이 때 애플리케이션에서 부하분산할 경우 슬레이브 목록/상태 관리 및 분산 스케줄링 등을 고려해야 한다. 따라서 LB를 쓰도록 하자. 
다만, 같은 네트워크일 경우엔 NAT로 구성하더라도 DSR과 같이 동작하기에 구태여 구성할 필요가 없다.
slave에는 I/O 스레드가 바이너리 로그 수신을, SQL 스레드가 바이너리 로그 실행을 진행한다. 
마스터에는 바이너리 로그, 슬레이브에는 릴레이 로그 파일이 생성된다.
바이너리 로그에는 데이터를 갱신하는 처리만이 기록되고 데이터를 참조하는 쿼리는 기록되지 않는다. 
또한 바이너리 로그는 리플리케이션 외에도 풀백업에서 갱신된 내용만 보관하고자 할 경우에도 사용된다. 
mysqlbinlog command로 텍스트 형식으로 변환할 수 있다.
릴레이 로그란, 슬레이브의 I/O 쓰레드가 마스터로부터 갱신로그(갱신관련 쿼리를 기록한 데이터)를 수신해서 슬레이브 측에 저장한 것이다. 
따라서 그 내용은 바이너리 로그와 동일하다. 바이너리 로그가 삭제되면 SQL 쓰레드에 의해 자동으로 삭제된다.
바이너리 로그에 기록되어 있는 쿼리의 실행은 테이블에 액세스하여 내용을 변경할 수 있기에 지연현상을 초래할 수 있다. 
또한 I/O 스레드가 비동기로 동작하기에 마스터에서 생성한 바이너리 로그가 슬레이브에 수신되기 전에 장애가 날 경우 손실이 발생할 수 있다.

 - 리플리케이션 상황 확인
마스터의 상황 확인
SHOW MASTER STATUS: 마스터의 바이너리 로그 상황을 확인
SHOW MASTER LOGS: 바이너리 로그는 정기적으로 삭제해야 한다. 
삭제 시엔 마스터에서 PURGE MASTER LOGS문으로 삭제한다. 
PURGE MASTER LOGS TO 'mysql-bin.000003' 3은 남고 이보다 오래된 1, 2가 삭제된다.

슬레이브의 상황 확인
SHOW SLAVE STATUS
//SLAVE_IO_Running과 SLAVE_SQL_Running 중 하나가 Yes가 아닐 경우 리플리케이션은 중지한다.
```